// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PPX_PPX_H_
#define FLATBUFFERS_GENERATED_PPX_PPX_H_

#include "flatbuffers/flatbuffers.h"

namespace ppx {

struct Message;

struct Tensor;

struct Handshake;

struct HandshakeResult;

struct Run;

struct RunResult;

struct Sample;

struct SampleResult;

struct Observe;

struct ObserveResult;

struct Tag;

struct TagResult;

struct Forward;

struct ForwardResult;

struct Backward;

struct BackwardResult;

struct Reset;

struct Normal;

struct Uniform;

struct Categorical;

struct Poisson;

enum MessageBody {
  MessageBody_NONE = 0,
  MessageBody_Handshake = 1,
  MessageBody_HandshakeResult = 2,
  MessageBody_Run = 3,
  MessageBody_RunResult = 4,
  MessageBody_Sample = 5,
  MessageBody_SampleResult = 6,
  MessageBody_Observe = 7,
  MessageBody_ObserveResult = 8,
  MessageBody_Tag = 9,
  MessageBody_TagResult = 10,
  MessageBody_Forward = 11,
  MessageBody_ForwardResult = 12,
  MessageBody_Backward = 13,
  MessageBody_BackwardResult = 14,
  MessageBody_Reset = 15,
  MessageBody_MIN = MessageBody_NONE,
  MessageBody_MAX = MessageBody_Reset
};

inline const MessageBody (&EnumValuesMessageBody())[16] {
  static const MessageBody values[] = {
    MessageBody_NONE,
    MessageBody_Handshake,
    MessageBody_HandshakeResult,
    MessageBody_Run,
    MessageBody_RunResult,
    MessageBody_Sample,
    MessageBody_SampleResult,
    MessageBody_Observe,
    MessageBody_ObserveResult,
    MessageBody_Tag,
    MessageBody_TagResult,
    MessageBody_Forward,
    MessageBody_ForwardResult,
    MessageBody_Backward,
    MessageBody_BackwardResult,
    MessageBody_Reset
  };
  return values;
}

inline const char * const *EnumNamesMessageBody() {
  static const char * const names[] = {
    "NONE",
    "Handshake",
    "HandshakeResult",
    "Run",
    "RunResult",
    "Sample",
    "SampleResult",
    "Observe",
    "ObserveResult",
    "Tag",
    "TagResult",
    "Forward",
    "ForwardResult",
    "Backward",
    "BackwardResult",
    "Reset",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageBody(MessageBody e) {
  if (e < MessageBody_NONE || e > MessageBody_Reset) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageBody()[index];
}

template<typename T> struct MessageBodyTraits {
  static const MessageBody enum_value = MessageBody_NONE;
};

template<> struct MessageBodyTraits<Handshake> {
  static const MessageBody enum_value = MessageBody_Handshake;
};

template<> struct MessageBodyTraits<HandshakeResult> {
  static const MessageBody enum_value = MessageBody_HandshakeResult;
};

template<> struct MessageBodyTraits<Run> {
  static const MessageBody enum_value = MessageBody_Run;
};

template<> struct MessageBodyTraits<RunResult> {
  static const MessageBody enum_value = MessageBody_RunResult;
};

template<> struct MessageBodyTraits<Sample> {
  static const MessageBody enum_value = MessageBody_Sample;
};

template<> struct MessageBodyTraits<SampleResult> {
  static const MessageBody enum_value = MessageBody_SampleResult;
};

template<> struct MessageBodyTraits<Observe> {
  static const MessageBody enum_value = MessageBody_Observe;
};

template<> struct MessageBodyTraits<ObserveResult> {
  static const MessageBody enum_value = MessageBody_ObserveResult;
};

template<> struct MessageBodyTraits<Tag> {
  static const MessageBody enum_value = MessageBody_Tag;
};

template<> struct MessageBodyTraits<TagResult> {
  static const MessageBody enum_value = MessageBody_TagResult;
};

template<> struct MessageBodyTraits<Forward> {
  static const MessageBody enum_value = MessageBody_Forward;
};

template<> struct MessageBodyTraits<ForwardResult> {
  static const MessageBody enum_value = MessageBody_ForwardResult;
};

template<> struct MessageBodyTraits<Backward> {
  static const MessageBody enum_value = MessageBody_Backward;
};

template<> struct MessageBodyTraits<BackwardResult> {
  static const MessageBody enum_value = MessageBody_BackwardResult;
};

template<> struct MessageBodyTraits<Reset> {
  static const MessageBody enum_value = MessageBody_Reset;
};

bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type);
bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Distribution {
  Distribution_NONE = 0,
  Distribution_Normal = 1,
  Distribution_Uniform = 2,
  Distribution_Categorical = 3,
  Distribution_Poisson = 4,
  Distribution_MIN = Distribution_NONE,
  Distribution_MAX = Distribution_Poisson
};

inline const Distribution (&EnumValuesDistribution())[5] {
  static const Distribution values[] = {
    Distribution_NONE,
    Distribution_Normal,
    Distribution_Uniform,
    Distribution_Categorical,
    Distribution_Poisson
  };
  return values;
}

inline const char * const *EnumNamesDistribution() {
  static const char * const names[] = {
    "NONE",
    "Normal",
    "Uniform",
    "Categorical",
    "Poisson",
    nullptr
  };
  return names;
}

inline const char *EnumNameDistribution(Distribution e) {
  if (e < Distribution_NONE || e > Distribution_Poisson) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesDistribution()[index];
}

template<typename T> struct DistributionTraits {
  static const Distribution enum_value = Distribution_NONE;
};

template<> struct DistributionTraits<Normal> {
  static const Distribution enum_value = Distribution_Normal;
};

template<> struct DistributionTraits<Uniform> {
  static const Distribution enum_value = Distribution_Uniform;
};

template<> struct DistributionTraits<Categorical> {
  static const Distribution enum_value = Distribution_Categorical;
};

template<> struct DistributionTraits<Poisson> {
  static const Distribution enum_value = Distribution_Poisson;
};

bool VerifyDistribution(flatbuffers::Verifier &verifier, const void *obj, Distribution type);
bool VerifyDistributionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BODY_TYPE = 4,
    VT_BODY = 6
  };
  MessageBody body_type() const {
    return static_cast<MessageBody>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const Handshake *body_as_Handshake() const {
    return body_type() == MessageBody_Handshake ? static_cast<const Handshake *>(body()) : nullptr;
  }
  const HandshakeResult *body_as_HandshakeResult() const {
    return body_type() == MessageBody_HandshakeResult ? static_cast<const HandshakeResult *>(body()) : nullptr;
  }
  const Run *body_as_Run() const {
    return body_type() == MessageBody_Run ? static_cast<const Run *>(body()) : nullptr;
  }
  const RunResult *body_as_RunResult() const {
    return body_type() == MessageBody_RunResult ? static_cast<const RunResult *>(body()) : nullptr;
  }
  const Sample *body_as_Sample() const {
    return body_type() == MessageBody_Sample ? static_cast<const Sample *>(body()) : nullptr;
  }
  const SampleResult *body_as_SampleResult() const {
    return body_type() == MessageBody_SampleResult ? static_cast<const SampleResult *>(body()) : nullptr;
  }
  const Observe *body_as_Observe() const {
    return body_type() == MessageBody_Observe ? static_cast<const Observe *>(body()) : nullptr;
  }
  const ObserveResult *body_as_ObserveResult() const {
    return body_type() == MessageBody_ObserveResult ? static_cast<const ObserveResult *>(body()) : nullptr;
  }
  const Tag *body_as_Tag() const {
    return body_type() == MessageBody_Tag ? static_cast<const Tag *>(body()) : nullptr;
  }
  const TagResult *body_as_TagResult() const {
    return body_type() == MessageBody_TagResult ? static_cast<const TagResult *>(body()) : nullptr;
  }
  const Forward *body_as_Forward() const {
    return body_type() == MessageBody_Forward ? static_cast<const Forward *>(body()) : nullptr;
  }
  const ForwardResult *body_as_ForwardResult() const {
    return body_type() == MessageBody_ForwardResult ? static_cast<const ForwardResult *>(body()) : nullptr;
  }
  const Backward *body_as_Backward() const {
    return body_type() == MessageBody_Backward ? static_cast<const Backward *>(body()) : nullptr;
  }
  const BackwardResult *body_as_BackwardResult() const {
    return body_type() == MessageBody_BackwardResult ? static_cast<const BackwardResult *>(body()) : nullptr;
  }
  const Reset *body_as_Reset() const {
    return body_type() == MessageBody_Reset ? static_cast<const Reset *>(body()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE) &&
           VerifyOffset(verifier, VT_BODY) &&
           VerifyMessageBody(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Handshake *Message::body_as<Handshake>() const {
  return body_as_Handshake();
}

template<> inline const HandshakeResult *Message::body_as<HandshakeResult>() const {
  return body_as_HandshakeResult();
}

template<> inline const Run *Message::body_as<Run>() const {
  return body_as_Run();
}

template<> inline const RunResult *Message::body_as<RunResult>() const {
  return body_as_RunResult();
}

template<> inline const Sample *Message::body_as<Sample>() const {
  return body_as_Sample();
}

template<> inline const SampleResult *Message::body_as<SampleResult>() const {
  return body_as_SampleResult();
}

template<> inline const Observe *Message::body_as<Observe>() const {
  return body_as_Observe();
}

template<> inline const ObserveResult *Message::body_as<ObserveResult>() const {
  return body_as_ObserveResult();
}

template<> inline const Tag *Message::body_as<Tag>() const {
  return body_as_Tag();
}

template<> inline const TagResult *Message::body_as<TagResult>() const {
  return body_as_TagResult();
}

template<> inline const Forward *Message::body_as<Forward>() const {
  return body_as_Forward();
}

template<> inline const ForwardResult *Message::body_as<ForwardResult>() const {
  return body_as_ForwardResult();
}

template<> inline const Backward *Message::body_as<Backward>() const {
  return body_as_Backward();
}

template<> inline const BackwardResult *Message::body_as<BackwardResult>() const {
  return body_as_BackwardResult();
}

template<> inline const Reset *Message::body_as<Reset>() const {
  return body_as_Reset();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_body_type(MessageBody body_type) {
    fbb_.AddElement<uint8_t>(Message::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(flatbuffers::Offset<void> body) {
    fbb_.AddOffset(Message::VT_BODY, body);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageBody body_type = MessageBody_NONE,
    flatbuffers::Offset<void> body = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_SHAPE = 6
  };
  const flatbuffers::Vector<double> *data() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DATA);
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(Tensor::VT_DATA, data);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *data = nullptr,
    const std::vector<int32_t> *shape = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return ppx::CreateTensor(
      _fbb,
      data__,
      shape__);
}

struct Handshake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_NAME = 4
  };
  const flatbuffers::String *system_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SYSTEM_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYSTEM_NAME) &&
           verifier.VerifyString(system_name()) &&
           verifier.EndTable();
  }
};

struct HandshakeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_system_name(flatbuffers::Offset<flatbuffers::String> system_name) {
    fbb_.AddOffset(Handshake::VT_SYSTEM_NAME, system_name);
  }
  explicit HandshakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandshakeBuilder &operator=(const HandshakeBuilder &);
  flatbuffers::Offset<Handshake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Handshake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Handshake> CreateHandshake(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> system_name = 0) {
  HandshakeBuilder builder_(_fbb);
  builder_.add_system_name(system_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Handshake> CreateHandshakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *system_name = nullptr) {
  auto system_name__ = system_name ? _fbb.CreateString(system_name) : 0;
  return ppx::CreateHandshake(
      _fbb,
      system_name__);
}

struct HandshakeResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_NAME = 4,
    VT_MODEL_NAME = 6
  };
  const flatbuffers::String *system_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SYSTEM_NAME);
  }
  const flatbuffers::String *model_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYSTEM_NAME) &&
           verifier.VerifyString(system_name()) &&
           VerifyOffset(verifier, VT_MODEL_NAME) &&
           verifier.VerifyString(model_name()) &&
           verifier.EndTable();
  }
};

struct HandshakeResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_system_name(flatbuffers::Offset<flatbuffers::String> system_name) {
    fbb_.AddOffset(HandshakeResult::VT_SYSTEM_NAME, system_name);
  }
  void add_model_name(flatbuffers::Offset<flatbuffers::String> model_name) {
    fbb_.AddOffset(HandshakeResult::VT_MODEL_NAME, model_name);
  }
  explicit HandshakeResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandshakeResultBuilder &operator=(const HandshakeResultBuilder &);
  flatbuffers::Offset<HandshakeResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeResult> CreateHandshakeResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> system_name = 0,
    flatbuffers::Offset<flatbuffers::String> model_name = 0) {
  HandshakeResultBuilder builder_(_fbb);
  builder_.add_model_name(model_name);
  builder_.add_system_name(system_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeResult> CreateHandshakeResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *system_name = nullptr,
    const char *model_name = nullptr) {
  auto system_name__ = system_name ? _fbb.CreateString(system_name) : 0;
  auto model_name__ = model_name ? _fbb.CreateString(model_name) : 0;
  return ppx::CreateHandshakeResult(
      _fbb,
      system_name__,
      model_name__);
}

struct Run FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RunBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RunBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RunBuilder &operator=(const RunBuilder &);
  flatbuffers::Offset<Run> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Run>(end);
    return o;
  }
};

inline flatbuffers::Offset<Run> CreateRun(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RunBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RunResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  const Tensor *result() const {
    return GetPointer<const Tensor *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
};

struct RunResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(flatbuffers::Offset<Tensor> result) {
    fbb_.AddOffset(RunResult::VT_RESULT, result);
  }
  explicit RunResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RunResultBuilder &operator=(const RunResultBuilder &);
  flatbuffers::Offset<RunResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RunResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<RunResult> CreateRunResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> result = 0) {
  RunResultBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct Sample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_NAME = 6,
    VT_DISTRIBUTION_TYPE = 8,
    VT_DISTRIBUTION = 10,
    VT_CONTROL = 12,
    VT_REPLACE = 14
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Distribution distribution_type() const {
    return static_cast<Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const Normal *distribution_as_Normal() const {
    return distribution_type() == Distribution_Normal ? static_cast<const Normal *>(distribution()) : nullptr;
  }
  const Uniform *distribution_as_Uniform() const {
    return distribution_type() == Distribution_Uniform ? static_cast<const Uniform *>(distribution()) : nullptr;
  }
  const Categorical *distribution_as_Categorical() const {
    return distribution_type() == Distribution_Categorical ? static_cast<const Categorical *>(distribution()) : nullptr;
  }
  const Poisson *distribution_as_Poisson() const {
    return distribution_type() == Distribution_Poisson ? static_cast<const Poisson *>(distribution()) : nullptr;
  }
  bool control() const {
    return GetField<uint8_t>(VT_CONTROL, 1) != 0;
  }
  bool replace() const {
    return GetField<uint8_t>(VT_REPLACE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           VerifyField<uint8_t>(verifier, VT_CONTROL) &&
           VerifyField<uint8_t>(verifier, VT_REPLACE) &&
           verifier.EndTable();
  }
};

template<> inline const Normal *Sample::distribution_as<Normal>() const {
  return distribution_as_Normal();
}

template<> inline const Uniform *Sample::distribution_as<Uniform>() const {
  return distribution_as_Uniform();
}

template<> inline const Categorical *Sample::distribution_as<Categorical>() const {
  return distribution_as_Categorical();
}

template<> inline const Poisson *Sample::distribution_as<Poisson>() const {
  return distribution_as_Poisson();
}

struct SampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Sample::VT_ADDRESS, address);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Sample::VT_NAME, name);
  }
  void add_distribution_type(Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(Sample::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(Sample::VT_DISTRIBUTION, distribution);
  }
  void add_control(bool control) {
    fbb_.AddElement<uint8_t>(Sample::VT_CONTROL, static_cast<uint8_t>(control), 1);
  }
  void add_replace(bool replace) {
    fbb_.AddElement<uint8_t>(Sample::VT_REPLACE, static_cast<uint8_t>(replace), 0);
  }
  explicit SampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SampleBuilder &operator=(const SampleBuilder &);
  flatbuffers::Offset<Sample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sample>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sample> CreateSample(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Distribution distribution_type = Distribution_NONE,
    flatbuffers::Offset<void> distribution = 0,
    bool control = true,
    bool replace = false) {
  SampleBuilder builder_(_fbb);
  builder_.add_distribution(distribution);
  builder_.add_name(name);
  builder_.add_address(address);
  builder_.add_replace(replace);
  builder_.add_control(control);
  builder_.add_distribution_type(distribution_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sample> CreateSampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    const char *name = nullptr,
    Distribution distribution_type = Distribution_NONE,
    flatbuffers::Offset<void> distribution = 0,
    bool control = true,
    bool replace = false) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ppx::CreateSample(
      _fbb,
      address__,
      name__,
      distribution_type,
      distribution,
      control,
      replace);
}

struct SampleResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  const Tensor *result() const {
    return GetPointer<const Tensor *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
};

struct SampleResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(flatbuffers::Offset<Tensor> result) {
    fbb_.AddOffset(SampleResult::VT_RESULT, result);
  }
  explicit SampleResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SampleResultBuilder &operator=(const SampleResultBuilder &);
  flatbuffers::Offset<SampleResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SampleResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<SampleResult> CreateSampleResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> result = 0) {
  SampleResultBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct Observe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_NAME = 6,
    VT_DISTRIBUTION_TYPE = 8,
    VT_DISTRIBUTION = 10,
    VT_VALUE = 12
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Distribution distribution_type() const {
    return static_cast<Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const Normal *distribution_as_Normal() const {
    return distribution_type() == Distribution_Normal ? static_cast<const Normal *>(distribution()) : nullptr;
  }
  const Uniform *distribution_as_Uniform() const {
    return distribution_type() == Distribution_Uniform ? static_cast<const Uniform *>(distribution()) : nullptr;
  }
  const Categorical *distribution_as_Categorical() const {
    return distribution_type() == Distribution_Categorical ? static_cast<const Categorical *>(distribution()) : nullptr;
  }
  const Poisson *distribution_as_Poisson() const {
    return distribution_type() == Distribution_Poisson ? static_cast<const Poisson *>(distribution()) : nullptr;
  }
  const Tensor *value() const {
    return GetPointer<const Tensor *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

template<> inline const Normal *Observe::distribution_as<Normal>() const {
  return distribution_as_Normal();
}

template<> inline const Uniform *Observe::distribution_as<Uniform>() const {
  return distribution_as_Uniform();
}

template<> inline const Categorical *Observe::distribution_as<Categorical>() const {
  return distribution_as_Categorical();
}

template<> inline const Poisson *Observe::distribution_as<Poisson>() const {
  return distribution_as_Poisson();
}

struct ObserveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Observe::VT_ADDRESS, address);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Observe::VT_NAME, name);
  }
  void add_distribution_type(Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(Observe::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(Observe::VT_DISTRIBUTION, distribution);
  }
  void add_value(flatbuffers::Offset<Tensor> value) {
    fbb_.AddOffset(Observe::VT_VALUE, value);
  }
  explicit ObserveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObserveBuilder &operator=(const ObserveBuilder &);
  flatbuffers::Offset<Observe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Observe>(end);
    return o;
  }
};

inline flatbuffers::Offset<Observe> CreateObserve(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Distribution distribution_type = Distribution_NONE,
    flatbuffers::Offset<void> distribution = 0,
    flatbuffers::Offset<Tensor> value = 0) {
  ObserveBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_distribution(distribution);
  builder_.add_name(name);
  builder_.add_address(address);
  builder_.add_distribution_type(distribution_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Observe> CreateObserveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    const char *name = nullptr,
    Distribution distribution_type = Distribution_NONE,
    flatbuffers::Offset<void> distribution = 0,
    flatbuffers::Offset<Tensor> value = 0) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ppx::CreateObserve(
      _fbb,
      address__,
      name__,
      distribution_type,
      distribution,
      value);
}

struct ObserveResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ObserveResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ObserveResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObserveResultBuilder &operator=(const ObserveResultBuilder &);
  flatbuffers::Offset<ObserveResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObserveResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObserveResult> CreateObserveResult(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ObserveResultBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Tag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_NAME = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Tensor *value() const {
    return GetPointer<const Tensor *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct TagBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Tag::VT_ADDRESS, address);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tag::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<Tensor> value) {
    fbb_.AddOffset(Tag::VT_VALUE, value);
  }
  explicit TagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagBuilder &operator=(const TagBuilder &);
  flatbuffers::Offset<Tag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tag>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tag> CreateTag(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Tensor> value = 0) {
  TagBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_address(address);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tag> CreateTagDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    const char *name = nullptr,
    flatbuffers::Offset<Tensor> value = 0) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ppx::CreateTag(
      _fbb,
      address__,
      name__,
      value);
}

struct TagResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TagResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TagResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagResultBuilder &operator=(const TagResultBuilder &);
  flatbuffers::Offset<TagResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagResult> CreateTagResult(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TagResultBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Forward FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUT = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Tensor *input() const {
    return GetPointer<const Tensor *>(VT_INPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           verifier.EndTable();
  }
};

struct ForwardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Forward::VT_NAME, name);
  }
  void add_input(flatbuffers::Offset<Tensor> input) {
    fbb_.AddOffset(Forward::VT_INPUT, input);
  }
  explicit ForwardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ForwardBuilder &operator=(const ForwardBuilder &);
  flatbuffers::Offset<Forward> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Forward>(end);
    return o;
  }
};

inline flatbuffers::Offset<Forward> CreateForward(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Tensor> input = 0) {
  ForwardBuilder builder_(_fbb);
  builder_.add_input(input);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Forward> CreateForwardDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Tensor> input = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ppx::CreateForward(
      _fbb,
      name__,
      input);
}

struct ForwardResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT = 4
  };
  const Tensor *output() const {
    return GetPointer<const Tensor *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           verifier.EndTable();
  }
};

struct ForwardResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output(flatbuffers::Offset<Tensor> output) {
    fbb_.AddOffset(ForwardResult::VT_OUTPUT, output);
  }
  explicit ForwardResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ForwardResultBuilder &operator=(const ForwardResultBuilder &);
  flatbuffers::Offset<ForwardResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ForwardResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<ForwardResult> CreateForwardResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> output = 0) {
  ForwardResultBuilder builder_(_fbb);
  builder_.add_output(output);
  return builder_.Finish();
}

struct Backward FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUT = 6,
    VT_GRAD_OUTPUT = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Tensor *input() const {
    return GetPointer<const Tensor *>(VT_INPUT);
  }
  const Tensor *grad_output() const {
    return GetPointer<const Tensor *>(VT_GRAD_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyTable(input()) &&
           VerifyOffset(verifier, VT_GRAD_OUTPUT) &&
           verifier.VerifyTable(grad_output()) &&
           verifier.EndTable();
  }
};

struct BackwardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Backward::VT_NAME, name);
  }
  void add_input(flatbuffers::Offset<Tensor> input) {
    fbb_.AddOffset(Backward::VT_INPUT, input);
  }
  void add_grad_output(flatbuffers::Offset<Tensor> grad_output) {
    fbb_.AddOffset(Backward::VT_GRAD_OUTPUT, grad_output);
  }
  explicit BackwardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BackwardBuilder &operator=(const BackwardBuilder &);
  flatbuffers::Offset<Backward> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Backward>(end);
    return o;
  }
};

inline flatbuffers::Offset<Backward> CreateBackward(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Tensor> input = 0,
    flatbuffers::Offset<Tensor> grad_output = 0) {
  BackwardBuilder builder_(_fbb);
  builder_.add_grad_output(grad_output);
  builder_.add_input(input);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Backward> CreateBackwardDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Tensor> input = 0,
    flatbuffers::Offset<Tensor> grad_output = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ppx::CreateBackward(
      _fbb,
      name__,
      input,
      grad_output);
}

struct BackwardResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAD_INPUT = 4
  };
  const Tensor *grad_input() const {
    return GetPointer<const Tensor *>(VT_GRAD_INPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRAD_INPUT) &&
           verifier.VerifyTable(grad_input()) &&
           verifier.EndTable();
  }
};

struct BackwardResultBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_grad_input(flatbuffers::Offset<Tensor> grad_input) {
    fbb_.AddOffset(BackwardResult::VT_GRAD_INPUT, grad_input);
  }
  explicit BackwardResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BackwardResultBuilder &operator=(const BackwardResultBuilder &);
  flatbuffers::Offset<BackwardResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BackwardResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<BackwardResult> CreateBackwardResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> grad_input = 0) {
  BackwardResultBuilder builder_(_fbb);
  builder_.add_grad_input(grad_input);
  return builder_.Finish();
}

struct Reset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ResetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResetBuilder &operator=(const ResetBuilder &);
  flatbuffers::Offset<Reset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reset>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reset> CreateReset(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ResetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Normal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEAN = 4,
    VT_STDDEV = 6
  };
  const Tensor *mean() const {
    return GetPointer<const Tensor *>(VT_MEAN);
  }
  const Tensor *stddev() const {
    return GetPointer<const Tensor *>(VT_STDDEV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyTable(mean()) &&
           VerifyOffset(verifier, VT_STDDEV) &&
           verifier.VerifyTable(stddev()) &&
           verifier.EndTable();
  }
};

struct NormalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mean(flatbuffers::Offset<Tensor> mean) {
    fbb_.AddOffset(Normal::VT_MEAN, mean);
  }
  void add_stddev(flatbuffers::Offset<Tensor> stddev) {
    fbb_.AddOffset(Normal::VT_STDDEV, stddev);
  }
  explicit NormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormalBuilder &operator=(const NormalBuilder &);
  flatbuffers::Offset<Normal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Normal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Normal> CreateNormal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> mean = 0,
    flatbuffers::Offset<Tensor> stddev = 0) {
  NormalBuilder builder_(_fbb);
  builder_.add_stddev(stddev);
  builder_.add_mean(mean);
  return builder_.Finish();
}

struct Uniform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW = 4,
    VT_HIGH = 6
  };
  const Tensor *low() const {
    return GetPointer<const Tensor *>(VT_LOW);
  }
  const Tensor *high() const {
    return GetPointer<const Tensor *>(VT_HIGH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOW) &&
           verifier.VerifyTable(low()) &&
           VerifyOffset(verifier, VT_HIGH) &&
           verifier.VerifyTable(high()) &&
           verifier.EndTable();
  }
};

struct UniformBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_low(flatbuffers::Offset<Tensor> low) {
    fbb_.AddOffset(Uniform::VT_LOW, low);
  }
  void add_high(flatbuffers::Offset<Tensor> high) {
    fbb_.AddOffset(Uniform::VT_HIGH, high);
  }
  explicit UniformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniformBuilder &operator=(const UniformBuilder &);
  flatbuffers::Offset<Uniform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uniform>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uniform> CreateUniform(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> low = 0,
    flatbuffers::Offset<Tensor> high = 0) {
  UniformBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  return builder_.Finish();
}

struct Categorical FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROBS = 4
  };
  const Tensor *probs() const {
    return GetPointer<const Tensor *>(VT_PROBS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROBS) &&
           verifier.VerifyTable(probs()) &&
           verifier.EndTable();
  }
};

struct CategoricalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_probs(flatbuffers::Offset<Tensor> probs) {
    fbb_.AddOffset(Categorical::VT_PROBS, probs);
  }
  explicit CategoricalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CategoricalBuilder &operator=(const CategoricalBuilder &);
  flatbuffers::Offset<Categorical> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Categorical>(end);
    return o;
  }
};

inline flatbuffers::Offset<Categorical> CreateCategorical(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> probs = 0) {
  CategoricalBuilder builder_(_fbb);
  builder_.add_probs(probs);
  return builder_.Finish();
}

struct Poisson FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4
  };
  const Tensor *rate() const {
    return GetPointer<const Tensor *>(VT_RATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RATE) &&
           verifier.VerifyTable(rate()) &&
           verifier.EndTable();
  }
};

struct PoissonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rate(flatbuffers::Offset<Tensor> rate) {
    fbb_.AddOffset(Poisson::VT_RATE, rate);
  }
  explicit PoissonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoissonBuilder &operator=(const PoissonBuilder &);
  flatbuffers::Offset<Poisson> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Poisson>(end);
    return o;
  }
};

inline flatbuffers::Offset<Poisson> CreatePoisson(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Tensor> rate = 0) {
  PoissonBuilder builder_(_fbb);
  builder_.add_rate(rate);
  return builder_.Finish();
}

inline bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type) {
  switch (type) {
    case MessageBody_NONE: {
      return true;
    }
    case MessageBody_Handshake: {
      auto ptr = reinterpret_cast<const Handshake *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_HandshakeResult: {
      auto ptr = reinterpret_cast<const HandshakeResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Run: {
      auto ptr = reinterpret_cast<const Run *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_RunResult: {
      auto ptr = reinterpret_cast<const RunResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Sample: {
      auto ptr = reinterpret_cast<const Sample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_SampleResult: {
      auto ptr = reinterpret_cast<const SampleResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Observe: {
      auto ptr = reinterpret_cast<const Observe *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_ObserveResult: {
      auto ptr = reinterpret_cast<const ObserveResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Tag: {
      auto ptr = reinterpret_cast<const Tag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_TagResult: {
      auto ptr = reinterpret_cast<const TagResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Forward: {
      auto ptr = reinterpret_cast<const Forward *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_ForwardResult: {
      auto ptr = reinterpret_cast<const ForwardResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Backward: {
      auto ptr = reinterpret_cast<const Backward *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_BackwardResult: {
      auto ptr = reinterpret_cast<const BackwardResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Reset: {
      auto ptr = reinterpret_cast<const Reset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageBody(
        verifier,  values->Get(i), types->GetEnum<MessageBody>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDistribution(flatbuffers::Verifier &verifier, const void *obj, Distribution type) {
  switch (type) {
    case Distribution_NONE: {
      return true;
    }
    case Distribution_Normal: {
      auto ptr = reinterpret_cast<const Normal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution_Uniform: {
      auto ptr = reinterpret_cast<const Uniform *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution_Categorical: {
      auto ptr = reinterpret_cast<const Categorical *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution_Poisson: {
      auto ptr = reinterpret_cast<const Poisson *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyDistributionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDistribution(
        verifier,  values->Get(i), types->GetEnum<Distribution>(i))) {
      return false;
    }
  }
  return true;
}

inline const ppx::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<ppx::Message>(buf);
}

inline const ppx::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ppx::Message>(buf);
}

inline const char *MessageIdentifier() {
  return "PPXF";
}

inline bool MessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageIdentifier());
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ppx::Message>(MessageIdentifier());
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ppx::Message>(MessageIdentifier());
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppx::Message> root) {
  fbb.Finish(root, MessageIdentifier());
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppx::Message> root) {
  fbb.FinishSizePrefixed(root, MessageIdentifier());
}

}  // namespace ppx

#endif  // FLATBUFFERS_GENERATED_PPX_PPX_H_
