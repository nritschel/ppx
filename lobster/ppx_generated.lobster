// automatically generated by the FlatBuffers compiler, do not modify

include "flatbuffers.lobster"

namespace ppx

enum + 
    MessageBody_NONE = 0,
    MessageBody_Handshake = 1,
    MessageBody_HandshakeResult = 2,
    MessageBody_Run = 3,
    MessageBody_RunResult = 4,
    MessageBody_Sample = 5,
    MessageBody_SampleResult = 6,
    MessageBody_Observe = 7,
    MessageBody_ObserveResult = 8,
    MessageBody_Tag = 9,
    MessageBody_TagResult = 10,
    MessageBody_Forward = 11,
    MessageBody_ForwardResult = 12,
    MessageBody_Backward = 13,
    MessageBody_BackwardResult = 14,
    MessageBody_BatchOperation = 15,
    MessageBody_BatchOperationResult = 16,
    MessageBody_Reset = 17

enum + 
    Distribution_NONE = 0,
    Distribution_Normal = 1,
    Distribution_Uniform = 2,
    Distribution_Categorical = 3,
    Distribution_Poisson = 4

struct Message

struct Tensor

struct Handshake

struct HandshakeResult

struct Run

struct RunResult

struct Sample

struct SampleResult

struct Observe

struct ObserveResult

struct Tag

struct TagResult

struct Forward

struct ForwardResult

struct Backward

struct BackwardResult

struct BatchOperation

struct BatchOperationResult

struct Reset

struct Normal

struct Uniform

struct Categorical

struct Poisson

struct Message : flatbuffers_handle
    def body_type():
        buf_.flatbuffers_field_int8(pos_, 4, 0)
    def body_as_Handshake():
        ppx_Handshake { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_HandshakeResult():
        ppx_HandshakeResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Run():
        ppx_Run { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_RunResult():
        ppx_RunResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Sample():
        ppx_Sample { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_SampleResult():
        ppx_SampleResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Observe():
        ppx_Observe { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_ObserveResult():
        ppx_ObserveResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Tag():
        ppx_Tag { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_TagResult():
        ppx_TagResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Forward():
        ppx_Forward { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_ForwardResult():
        ppx_ForwardResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Backward():
        ppx_Backward { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_BackwardResult():
        ppx_BackwardResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_BatchOperation():
        ppx_BatchOperation { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_BatchOperationResult():
        ppx_BatchOperationResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Reset():
        ppx_Reset { buf_, buf_.flatbuffers_field_table(pos_, 6) }

def GetRootAsMessage(buf:string): Message { buf, buf.flatbuffers_indirect(0) }

def MessageStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def MessageAddBodyType(b_:flatbuffers_builder, body_type:int):
    b_.PrependUint8Slot(0, body_type, 0)
def MessageAddBody(b_:flatbuffers_builder, body:int):
    b_.PrependUOffsetTRelativeSlot(1, body, 0)
def MessageEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Tensor : flatbuffers_handle
    def data(i:int):
        buf_.read_float64_le(buf_.flatbuffers_field_vector(pos_, 4) + i * 8)
    def data_length():
        buf_.flatbuffers_field_vector_len(pos_, 4)
    def shape(i:int):
        buf_.read_int32_le(buf_.flatbuffers_field_vector(pos_, 6) + i * 4)
    def shape_length():
        buf_.flatbuffers_field_vector_len(pos_, 6)

def GetRootAsTensor(buf:string): Tensor { buf, buf.flatbuffers_indirect(0) }

def TensorStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def TensorAddData(b_:flatbuffers_builder, data:int):
    b_.PrependUOffsetTRelativeSlot(0, data, 0)
def TensorStartDataVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(8, n_, 8)
def TensorCreateDataVector(b_:flatbuffers_builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    b_.EndVector(v_.length)
def TensorAddShape(b_:flatbuffers_builder, shape:int):
    b_.PrependUOffsetTRelativeSlot(1, shape, 0)
def TensorStartShapeVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(4, n_, 4)
def TensorCreateShapeVector(b_:flatbuffers_builder, v_:[int]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependInt32(e_)
    b_.EndVector(v_.length)
def TensorEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Handshake : flatbuffers_handle
    def system_name():
        buf_.flatbuffers_field_string(pos_, 4)

def GetRootAsHandshake(buf:string): Handshake { buf, buf.flatbuffers_indirect(0) }

def HandshakeStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def HandshakeAddSystemName(b_:flatbuffers_builder, system_name:int):
    b_.PrependUOffsetTRelativeSlot(0, system_name, 0)
def HandshakeEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct HandshakeResult : flatbuffers_handle
    def system_name():
        buf_.flatbuffers_field_string(pos_, 4)
    def model_name():
        buf_.flatbuffers_field_string(pos_, 6)

def GetRootAsHandshakeResult(buf:string): HandshakeResult { buf, buf.flatbuffers_indirect(0) }

def HandshakeResultStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def HandshakeResultAddSystemName(b_:flatbuffers_builder, system_name:int):
    b_.PrependUOffsetTRelativeSlot(0, system_name, 0)
def HandshakeResultAddModelName(b_:flatbuffers_builder, model_name:int):
    b_.PrependUOffsetTRelativeSlot(1, model_name, 0)
def HandshakeResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Run : flatbuffers_handle

def GetRootAsRun(buf:string): Run { buf, buf.flatbuffers_indirect(0) }

def RunStart(b_:flatbuffers_builder):
    b_.StartObject(0)
def RunEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct RunResult : flatbuffers_handle
    def result():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsRunResult(buf:string): RunResult { buf, buf.flatbuffers_indirect(0) }

def RunResultStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def RunResultAddResult(b_:flatbuffers_builder, result:int):
    b_.PrependUOffsetTRelativeSlot(0, result, 0)
def RunResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Sample : flatbuffers_handle
    def address():
        buf_.flatbuffers_field_string(pos_, 4)
    def name():
        buf_.flatbuffers_field_string(pos_, 6)
    def distribution_type():
        buf_.flatbuffers_field_int8(pos_, 8, 0)
    def distribution_as_Normal():
        ppx_Normal { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Uniform():
        ppx_Uniform { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Categorical():
        ppx_Categorical { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Poisson():
        ppx_Poisson { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def control():
        buf_.flatbuffers_field_int8(pos_, 12, 1)
    def replace():
        buf_.flatbuffers_field_int8(pos_, 14, 0)

def GetRootAsSample(buf:string): Sample { buf, buf.flatbuffers_indirect(0) }

def SampleStart(b_:flatbuffers_builder):
    b_.StartObject(6)
def SampleAddAddress(b_:flatbuffers_builder, address:int):
    b_.PrependUOffsetTRelativeSlot(0, address, 0)
def SampleAddName(b_:flatbuffers_builder, name:int):
    b_.PrependUOffsetTRelativeSlot(1, name, 0)
def SampleAddDistributionType(b_:flatbuffers_builder, distribution_type:int):
    b_.PrependUint8Slot(2, distribution_type, 0)
def SampleAddDistribution(b_:flatbuffers_builder, distribution:int):
    b_.PrependUOffsetTRelativeSlot(3, distribution, 0)
def SampleAddControl(b_:flatbuffers_builder, control:int):
    b_.PrependBoolSlot(4, control, 1)
def SampleAddReplace(b_:flatbuffers_builder, replace:int):
    b_.PrependBoolSlot(5, replace, 0)
def SampleEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct SampleResult : flatbuffers_handle
    def result():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsSampleResult(buf:string): SampleResult { buf, buf.flatbuffers_indirect(0) }

def SampleResultStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def SampleResultAddResult(b_:flatbuffers_builder, result:int):
    b_.PrependUOffsetTRelativeSlot(0, result, 0)
def SampleResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Observe : flatbuffers_handle
    def address():
        buf_.flatbuffers_field_string(pos_, 4)
    def name():
        buf_.flatbuffers_field_string(pos_, 6)
    def distribution_type():
        buf_.flatbuffers_field_int8(pos_, 8, 0)
    def distribution_as_Normal():
        ppx_Normal { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Uniform():
        ppx_Uniform { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Categorical():
        ppx_Categorical { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Poisson():
        ppx_Poisson { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def value_():
        o := buf_.flatbuffers_field_table(pos_, 12)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsObserve(buf:string): Observe { buf, buf.flatbuffers_indirect(0) }

def ObserveStart(b_:flatbuffers_builder):
    b_.StartObject(5)
def ObserveAddAddress(b_:flatbuffers_builder, address:int):
    b_.PrependUOffsetTRelativeSlot(0, address, 0)
def ObserveAddName(b_:flatbuffers_builder, name:int):
    b_.PrependUOffsetTRelativeSlot(1, name, 0)
def ObserveAddDistributionType(b_:flatbuffers_builder, distribution_type:int):
    b_.PrependUint8Slot(2, distribution_type, 0)
def ObserveAddDistribution(b_:flatbuffers_builder, distribution:int):
    b_.PrependUOffsetTRelativeSlot(3, distribution, 0)
def ObserveAddValue_(b_:flatbuffers_builder, value_:int):
    b_.PrependUOffsetTRelativeSlot(4, value_, 0)
def ObserveEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct ObserveResult : flatbuffers_handle

def GetRootAsObserveResult(buf:string): ObserveResult { buf, buf.flatbuffers_indirect(0) }

def ObserveResultStart(b_:flatbuffers_builder):
    b_.StartObject(0)
def ObserveResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Tag : flatbuffers_handle
    def address():
        buf_.flatbuffers_field_string(pos_, 4)
    def name():
        buf_.flatbuffers_field_string(pos_, 6)
    def value_():
        o := buf_.flatbuffers_field_table(pos_, 8)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsTag(buf:string): Tag { buf, buf.flatbuffers_indirect(0) }

def TagStart(b_:flatbuffers_builder):
    b_.StartObject(3)
def TagAddAddress(b_:flatbuffers_builder, address:int):
    b_.PrependUOffsetTRelativeSlot(0, address, 0)
def TagAddName(b_:flatbuffers_builder, name:int):
    b_.PrependUOffsetTRelativeSlot(1, name, 0)
def TagAddValue_(b_:flatbuffers_builder, value_:int):
    b_.PrependUOffsetTRelativeSlot(2, value_, 0)
def TagEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct TagResult : flatbuffers_handle

def GetRootAsTagResult(buf:string): TagResult { buf, buf.flatbuffers_indirect(0) }

def TagResultStart(b_:flatbuffers_builder):
    b_.StartObject(0)
def TagResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Forward : flatbuffers_handle
    def name():
        buf_.flatbuffers_field_string(pos_, 4)
    def input():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsForward(buf:string): Forward { buf, buf.flatbuffers_indirect(0) }

def ForwardStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def ForwardAddName(b_:flatbuffers_builder, name:int):
    b_.PrependUOffsetTRelativeSlot(0, name, 0)
def ForwardAddInput(b_:flatbuffers_builder, input:int):
    b_.PrependUOffsetTRelativeSlot(1, input, 0)
def ForwardEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct ForwardResult : flatbuffers_handle
    def output():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsForwardResult(buf:string): ForwardResult { buf, buf.flatbuffers_indirect(0) }

def ForwardResultStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def ForwardResultAddOutput(b_:flatbuffers_builder, output:int):
    b_.PrependUOffsetTRelativeSlot(0, output, 0)
def ForwardResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Backward : flatbuffers_handle
    def name():
        buf_.flatbuffers_field_string(pos_, 4)
    def input():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil
    def grad_output():
        o := buf_.flatbuffers_field_table(pos_, 8)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsBackward(buf:string): Backward { buf, buf.flatbuffers_indirect(0) }

def BackwardStart(b_:flatbuffers_builder):
    b_.StartObject(3)
def BackwardAddName(b_:flatbuffers_builder, name:int):
    b_.PrependUOffsetTRelativeSlot(0, name, 0)
def BackwardAddInput(b_:flatbuffers_builder, input:int):
    b_.PrependUOffsetTRelativeSlot(1, input, 0)
def BackwardAddGradOutput(b_:flatbuffers_builder, grad_output:int):
    b_.PrependUOffsetTRelativeSlot(2, grad_output, 0)
def BackwardEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct BackwardResult : flatbuffers_handle
    def grad_input():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsBackwardResult(buf:string): BackwardResult { buf, buf.flatbuffers_indirect(0) }

def BackwardResultStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def BackwardResultAddGradInput(b_:flatbuffers_builder, grad_input:int):
    b_.PrependUOffsetTRelativeSlot(0, grad_input, 0)
def BackwardResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct BatchOperation : flatbuffers_handle
    def operations(i:int):
        ppx_Message { buf_, buf_.flatbuffers_indirect(buf_.flatbuffers_field_vector(pos_, 4) + i * 4) }
    def operations_length():
        buf_.flatbuffers_field_vector_len(pos_, 4)

def GetRootAsBatchOperation(buf:string): BatchOperation { buf, buf.flatbuffers_indirect(0) }

def BatchOperationStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def BatchOperationAddOperations(b_:flatbuffers_builder, operations:int):
    b_.PrependUOffsetTRelativeSlot(0, operations, 0)
def BatchOperationStartOperationsVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(4, n_, 4)
def BatchOperationCreateOperationsVector(b_:flatbuffers_builder, v_:[int]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    b_.EndVector(v_.length)
def BatchOperationEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct BatchOperationResult : flatbuffers_handle
    def results(i:int):
        ppx_Message { buf_, buf_.flatbuffers_indirect(buf_.flatbuffers_field_vector(pos_, 4) + i * 4) }
    def results_length():
        buf_.flatbuffers_field_vector_len(pos_, 4)

def GetRootAsBatchOperationResult(buf:string): BatchOperationResult { buf, buf.flatbuffers_indirect(0) }

def BatchOperationResultStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def BatchOperationResultAddResults(b_:flatbuffers_builder, results:int):
    b_.PrependUOffsetTRelativeSlot(0, results, 0)
def BatchOperationResultStartResultsVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(4, n_, 4)
def BatchOperationResultCreateResultsVector(b_:flatbuffers_builder, v_:[int]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    b_.EndVector(v_.length)
def BatchOperationResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Reset : flatbuffers_handle

def GetRootAsReset(buf:string): Reset { buf, buf.flatbuffers_indirect(0) }

def ResetStart(b_:flatbuffers_builder):
    b_.StartObject(0)
def ResetEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Normal : flatbuffers_handle
    def mean():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil
    def stddev():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsNormal(buf:string): Normal { buf, buf.flatbuffers_indirect(0) }

def NormalStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def NormalAddMean(b_:flatbuffers_builder, mean:int):
    b_.PrependUOffsetTRelativeSlot(0, mean, 0)
def NormalAddStddev(b_:flatbuffers_builder, stddev:int):
    b_.PrependUOffsetTRelativeSlot(1, stddev, 0)
def NormalEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Uniform : flatbuffers_handle
    def low():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil
    def high():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsUniform(buf:string): Uniform { buf, buf.flatbuffers_indirect(0) }

def UniformStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def UniformAddLow(b_:flatbuffers_builder, low:int):
    b_.PrependUOffsetTRelativeSlot(0, low, 0)
def UniformAddHigh(b_:flatbuffers_builder, high:int):
    b_.PrependUOffsetTRelativeSlot(1, high, 0)
def UniformEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Categorical : flatbuffers_handle
    def probs():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsCategorical(buf:string): Categorical { buf, buf.flatbuffers_indirect(0) }

def CategoricalStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def CategoricalAddProbs(b_:flatbuffers_builder, probs:int):
    b_.PrependUOffsetTRelativeSlot(0, probs, 0)
def CategoricalEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Poisson : flatbuffers_handle
    def rate():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsPoisson(buf:string): Poisson { buf, buf.flatbuffers_indirect(0) }

def PoissonStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def PoissonAddRate(b_:flatbuffers_builder, rate:int):
    b_.PrependUOffsetTRelativeSlot(0, rate, 0)
def PoissonEnd(b_:flatbuffers_builder):
    b_.EndObject()

